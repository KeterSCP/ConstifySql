using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace ConstifySql;

[Generator]
public class SqlGenerator : IIncrementalGenerator
{
    private const string DefaultNamespace = "ConstifySql";
    private const string DefaultClassName = "SqlQueries";

    private static readonly char[] DirectorySeparatorChars = ['/'];
    // TODO: this could be parameterized from options
    private static readonly Regex QueryParametersRegex = new(@"[@:]\w+", RegexOptions.Compiled);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var generatorOptions = context.AnalyzerConfigOptionsProvider
            .Select((configOptions, _) =>
            {
                configOptions.GlobalOptions.TryGetValue("build_property.ConstifySql_Namespace", out var namespaceConfig);
                configOptions.GlobalOptions.TryGetValue("build_property.ConstifySql_ClassName", out var classNameConfig);
                configOptions.GlobalOptions.TryGetValue("build_property.ConstifySql_SplitByClassesFromRoot", out var splitByClassesFromRootConfig);
                configOptions.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace);

                return new GeneratorOptions(@namespace: namespaceConfig, className: classNameConfig, splitByClassesFromRoot: splitByClassesFromRootConfig, rootNamespace: rootNamespace);
            });

        var files = context.AdditionalTextsProvider.Where(f => f.Path.EndsWith(".sql"));

        var pathAndContents = files.Select((text, cancellationToken) =>
        {
            var content = text.GetText(cancellationToken)?.ToString() ?? "";

            return (Path: text.Path, Content: content);
        });

        var filesAndOptions = pathAndContents.Combine(generatorOptions);

        context.RegisterSourceOutput(filesAndOptions, Generate);
    }

    private static void Generate(
        SourceProductionContext context,
        ((string Path, string Content) PathAndContents, GeneratorOptions Options) generationContext)
    {
        var fileAbsolutePath = generationContext.PathAndContents.Path;
        var fileName = Path.GetFileNameWithoutExtension(generationContext.PathAndContents.Path);
        var content = generationContext.PathAndContents.Content;
        var queryParameters = QueryParametersRegex.Matches(content)
            .Cast<Match>()
            .Select(m => m.Value)
            .ToArray();

        var namespaceName = string.IsNullOrWhiteSpace(generationContext.Options.Namespace) ? DefaultNamespace : generationContext.Options.Namespace;
        var className = string.IsNullOrWhiteSpace(generationContext.Options.ClassName) ? DefaultClassName : generationContext.Options.ClassName;

        var splitFolders = GetSplitFolders(fileAbsolutePath, generationContext.Options);
        var generatedFileName = $"{GetGeneratedFileName(fileName, splitFolders)}.g.cs";

        var indentedStringBuilder = new IndentedStringBuilder();

        indentedStringBuilder.AppendLine("// This file was generated by ConstifySql source generator, any changes made to this file will be lost");
        indentedStringBuilder.AppendLine("// ReSharper Disable All");
        indentedStringBuilder.AppendLine($"namespace {namespaceName}");
        indentedStringBuilder.AppendLine("{");
        indentedStringBuilder.IncrementIndent();
        indentedStringBuilder.AppendLine($"public static partial class {className}");
        indentedStringBuilder.AppendLine("{");
        indentedStringBuilder.IncrementIndent();

        if (splitFolders.Length > 0)
        {
            foreach (var folder in splitFolders)
            {
                indentedStringBuilder.AppendLine($"public static partial class {folder}");
                indentedStringBuilder.AppendLine("{");
                indentedStringBuilder.IncrementIndent();
            }

            AppendParametersXmlDescription(indentedStringBuilder, queryParameters);
            indentedStringBuilder.AppendLine($"public const string {fileName} = {ToLiteral(content)};");

            foreach (var _ in splitFolders)
            {
                indentedStringBuilder.DecrementIndent();
                indentedStringBuilder.AppendLine("}");
            }
        }
        else
        {
            AppendParametersXmlDescription(indentedStringBuilder, queryParameters);
            indentedStringBuilder.AppendLine($"public const string {fileName} = {ToLiteral(content)};");
        }

        indentedStringBuilder.DecrementIndent();
        indentedStringBuilder.AppendLine("}");
        indentedStringBuilder.DecrementIndent();
        indentedStringBuilder.AppendLine("}");

        context.AddSource(generatedFileName, SourceText.From(indentedStringBuilder.ToString(), Encoding.UTF8));
    }

    private static string ToLiteral(string input)
    {
        return SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(input)).ToFullString();
    }

    private static void AppendParametersXmlDescription(IndentedStringBuilder sb, string[] queryParameters)
    {
        if (queryParameters.Length == 0)
        {
            return;
        }

        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Query parameters:");
        sb.AppendLine("/// <list type=\"bullet\">");

        foreach (var parameter in queryParameters)
        {
            sb.AppendLine($"/// <item><description>{parameter}</description></item>");
        }

        sb.AppendLine("/// </list>");
        sb.AppendLine("/// </summary>");
    }

    private static ReadOnlySpan<string> GetSplitFolders(string fileAbsolutePath, GeneratorOptions generatorOptions)
    {
        var normalizedFilePath = fileAbsolutePath.Replace('\\', '/');
        var root = string.IsNullOrWhiteSpace(generatorOptions.SplitByClassesFromRoot) ? generatorOptions.RootNamespace : generatorOptions.SplitByClassesFromRoot;

        if (!string.IsNullOrWhiteSpace(root))
        {
            var normalizedRoot = root!.Replace('\\', '/');

            var folders = normalizedFilePath
                .Substring(normalizedFilePath.LastIndexOf(normalizedRoot, StringComparison.Ordinal) + normalizedRoot.Length)
                .Split(DirectorySeparatorChars, StringSplitOptions.RemoveEmptyEntries)
                .AsSpan();

            return folders.Slice(0, folders.Length - 1); // Skip last element (sql file itself)
        }

        return ReadOnlySpan<string>.Empty;
    }

    private static string GetGeneratedFileName(string fileName, ReadOnlySpan<string> splitFolders)
    {
        if (splitFolders.Length == 0)
        {
            return fileName;
        }

        var fileNameSb = new StringBuilder();

        foreach (var folder in splitFolders)
        {
            fileNameSb.Append(folder);
            fileNameSb.Append('.');
        }

        fileNameSb.Append(fileName);

        return fileNameSb.ToString();
    }
}